import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:seg_medico/models/profilo.dart'; // Assicurati che questo sia corretto
import 'package:flutter/foundation.dart'; // Per @required se lo usi, altrimenti rimuovi

class ApiService {
  static const String _baseUrl = 'https://segreteriamedico.it/api/paziente';
  static const String _farmaciBaseUrl = 'https://segreteriamedico.it/api/farmaci'; // URL separato per i farmaci

  // 1. Richiesta OTP
  Future<bool> requestOtp(String codFis, String cellulare) async {
    final url = Uri.parse('$_baseUrl/otp/');
    try {
      final response = await http.post(
        url,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json, text/plain, */*',
        },
        body: json.encode({
          'codfis': codFis,
          'cellulare': cellulare,
        }),
      );

      if (response.statusCode == 200) {
        final Map<String, dynamic> data = json.decode(response.body);
        return data['success'] ?? false;
      } else {
        if (kDebugMode) {
          print('Errore OTP: ${response.statusCode} - ${response.body}');
        }
        return false;
      }
    } catch (e) {
      if (kDebugMode) {
        print('Eccezione requestOtp: $e');
      }
      return false;
    }
  }

  // 2. Login
  Future<String?> login(String codFis, String cellulare, String otpCode) async {
    final url = Uri.parse('$_baseUrl/login/');
    try {
      final response = await http.post(
        url,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json, text/plain, */*',
        },
        body: json.encode({
          'codfis': codFis,
          'cellulare': cellulare,
          'codice': otpCode,
        }),
      );

      if (response.statusCode == 200) {
        final Map<String, dynamic> data = json.decode(response.body);
        return data['token'];
      } else {
        if (kDebugMode) {
          print('Errore Login: ${response.statusCode} - ${response.body}');
        }
        return null;
      }
    } catch (e) {
      if (kDebugMode) {
        print('Eccezione login: $e');
      }
      return null;
    }
  }

  // 3. Recupera Informazioni Paziente
  Future<PatientInfoResponse?> getPatientInfo(String token) async {
    final url = Uri.parse('$_baseUrl/info/');
    try {
      final response = await http.get(
        url,
        headers: {
          'Authorization': token,
          'Accept': 'application/json, text/plain, */*',
        },
      );

      if (response.statusCode == 200) {
        final Map<String, dynamic> data = json.decode(response.body);
        return PatientInfoResponse.fromMap(data);
      } else {
        if (kDebugMode) {
          print('Errore getPatientInfo: ${response.statusCode} - ${response.body}');
        }
        return null;
      }
    } catch (e) {
      if (kDebugMode) {
        print('Eccezione getPatientInfo: $e');
      }
      return null;
    }
  }

  // 4. Recupera Appuntamenti
  Future<List<Appointment>> getAppointments(String token) async {
    final url = Uri.parse('$_baseUrl/appuntamenti/');
    try {
      final response = await http.get(
        url,
        headers: {
          'Authorization': token,
          'Accept': 'application/json, text/plain, */*',
        },
      );

      if (response.statusCode == 200) {
        final Map<String, dynamic> data = json.decode(response.body);
        final List<dynamic> appuntamentiJson = data['appuntamenti'] ?? [];
        return appuntamentiJson.map((json) => Appointment.fromMap(json)).toList();
      } else {
        if (kDebugMode) {
          print('Errore getAppointments: ${response.statusCode} - ${response.body}');
        }
        return [];
      }
    } catch (e) {
      if (kDebugMode) {
        print('Eccezione getAppointments: $e');
      }
      return [];
    }
  }

  // 5. Prenota Appuntamento (Slots e poi conferma appuntamento)
  // Primo step: Ottieni gli slot disponibili (se necessario, il tuo HAR mostra una chiamata a /slots/)
  Future<List<dynamic>> getAvailableSlots(String token, String dataRichiesta) async {
    final url = Uri.parse('$_baseUrl/slots/');
    try {
      final response = await http.post(
        url,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': token,
          'Accept': 'application/json, text/plain, */*',
        },
        body: json.encode({'data_richiesta': dataRichiesta}), // Esempio: "2025-08-01"
      );

      if (response.statusCode == 200) {
        final Map<String, dynamic> data = json.decode(response.body);
        // Assumendo che gli slot siano in una chiave 'slots' o simili
        return data['slots'] ?? [];
      } else {
        if (kDebugMode) {
          print('Errore getAvailableSlots: ${response.statusCode} - ${response.body}');
        }
        return [];
      }
    } catch (e) {
      if (kDebugMode) {
        print('Eccezione getAvailableSlots: $e');
      }
      return [];
    }
  }

  // Secondo step: Conferma/Crea appuntamento
  Future<BookAppointmentResponse?> bookAppointment(String token, int ambulatorioId, String data, String ora) async {
    final url = Uri.parse('$_baseUrl/appuntamento/');
    try {
      final response = await http.post(
        url,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': token,
          'Accept': 'application/json, text/plain, */*',
        },
        body: json.encode({
          'id': null, // Viene assegnato dal backend
          'ambulatorio_id': ambulatorioId,
          'data': data,
          'ora': ora,
        }),
      );

      if (response.statusCode == 200) {
        final Map<String, dynamic> data = json.decode(response.body);
        return BookAppointmentResponse.fromMap(data);
      } else {
        if (kDebugMode) {
          print('Errore bookAppointment: ${response.statusCode} - ${response.body}');
        }
        return null;
      }
    } catch (e) {
      if (kDebugMode) {
        print('Eccezione bookAppointment: $e');
      }
      return null;
    }
  }

  // 6. Annulla Appuntamento [La tua precedente simulazione era `cancelAppointment(String appointmentId, String token)`.
  // Basandomi sul tuo HAR, la chiamata è una DELETE a `/api/paziente/appuntamento/{id}/`]
  Future<bool> cancelAppointment(String appointmentId, String token) async {
    final url = Uri.parse('$_baseUrl/appuntamento/$appointmentId/'); // Corretto l'URL
    try {
      final response = await http.delete(
        url,
        headers: {
          'Authorization': token,
          'Accept': 'application/json, text/plain, */*',
        },
      );

      if (response.statusCode == 200 || response.statusCode == 204) { // 200 OK o 204 No Content
        return true;
      } else {
        if (kDebugMode) {
          print('Errore cancelAppointment: ${response.statusCode} - ${response.body}');
        }
        return false;
      }
    } catch (e) {
      if (kDebugMode) {
        print('Eccezione cancelAppointment: $e');
      }
      return false;
    }
  }

  // 7. Ordina Farmaco - Basato sull'analisi del file farmaci2.har.txt
  Future<OrderDrugResponse?> orderDrug(String token, String note, String farmacoId, int qty, int ambulatorioId) async {
    final url = Uri.parse('$_farmaciBaseUrl/'); // Usa l'URL base specifico per i farmaci
    try {
      final response = await http.post(
        url,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': token,
          'Accept': 'application/json, text/plain, */*',
        },
        body: json.encode({
          'note': note,
          'farmaco_id': farmacoId,
          'qty': qty,
          'ambulatorio_id': ambulatorioId,
        }),
      );

      if (response.statusCode == 200) {
        final Map<String, dynamic> data = json.decode(response.body);
        return OrderDrugResponse.fromMap(data);
      } else {
        if (kDebugMode) {
          print('Errore orderDrug: ${response.statusCode} - ${response.body}');
        }
        return null;
      }
    } catch (e) {
      if (kDebugMode) {
        print('Eccezione orderDrug: $e');
      }
      return null;
    }
  }

  // Logout (Gestito lato client, pulendo il token)
  // Non è stata trovata una chiamata API esplicita per il logout nei HAR forniti.
  // Si presume che il logout avvenga semplicemente cancellando il token di autenticazione salvato.
  Future<void> logout() async {
    // Implementazione nel AppProvider per pulire _authToken
  }
}

// --- Modelli Dati ---

// Risposta OTP
class OtpResponse {
  final bool success;

  OtpResponse({required this.success});

  factory OtpResponse.fromMap(Map<String, dynamic> map) {
    return OtpResponse(
      success: map['success'] as bool,
    );
  }
}

// Risposta Login
class LoginResponse {
  final String token;

  LoginResponse({required this.token});

  factory LoginResponse.fromMap(Map<String, dynamic> map) {
    return LoginResponse(
      token: map['token'] as String,
    );
  }
}

// Modello per le informazioni del paziente e del medico
// Potresti voler spostare Profilo, Medico, Ambulatorio in file separati
class PatientInfoResponse {
  final List<String> note;
  final Profilo paziente; // Riferimento al tuo modello Profilo esistente
  final Medico medico;
  final List<Ambulatorio> ambulatori;
  final bool app15gg;
  final String giorni;

  PatientInfoResponse({
    required this.note,
    required this.paziente,
    required this.medico,
    required this.ambulatori,
    required this.app15gg,
    required this.giorni,
  });

  factory PatientInfoResponse.fromMap(Map<String, dynamic> map) {
    return PatientInfoResponse(
      note: List<String>.from(map['note'] as List),
      paziente: Profilo.fromMap(map['paziente'] as Map<String, dynamic>),
      medico: Medico.fromMap(map['medico'] as Map<String, dynamic>),
      ambulatori: List<Ambulatorio>.from(
          (map['ambulatori'] as List<dynamic>).map((x) => Ambulatorio.fromMap(x as Map<String, dynamic>))),
      app15gg: map['app15gg'] as bool,
      giorni: map['giorni'] as String,
    );
  }
}

// Modello Medico
class Medico {
  final String nome;
  final bool servizio;
  final bool appuntamenti;
  final bool appuntamenti2;
  final bool consigli;
  final bool disdette;
  final bool farmaci;
  final int orario;

  Medico({
    required this.nome,
    required this.servizio,
    required this.appuntamenti,
    required this.appuntamenti2,
    required this.consigli,
    required this.disdette,
    required this.farmaci,
    required this.orario,
  });

  factory Medico.fromMap(Map<String, dynamic> map) {
    return Medico(
      nome: map['nome'] as String,
      servizio: map['servizio'] as bool,
      appuntamenti: map['appuntamenti'] as bool,
      appuntamenti2: map['appuntamenti2'] as bool,
      consigli: map['consigli'] as bool,
      disdette: map['disdette'] as bool,
      farmaci: map['farmaci'] as bool,
      orario: map['orario'] as int,
    );
  }
}

// Modello Ambulatorio
class Ambulatorio {
  final int id;
  final String nome;

  Ambulatorio({
    required this.id,
    required this.nome,
  });

  factory Ambulatorio.fromMap(Map<String, dynamic> map) {
    return Ambulatorio(
      id: map['id'] as int,
      nome: map['nome'] as String,
    );
  }
}

// Modello Appuntamento (se i tuoi appuntamenti hanno una struttura più complessa)
// Basato su appuntamenti:[] nell'HAR, questo è un placeholder. Dovrai riempirlo
// con i campi reali del tuo oggetto appuntamento se ne ha.
class Appointment {
  final String id; // O int, a seconda del tipo reale
  final String date;
  final String time;
  final String description;

  Appointment({
    required this.id,
    required this.date,
    required this.time,
    required this.description,
  });

  factory Appointment.fromMap(Map<String, dynamic> map) {
    // Esempio basato su un appuntamento simulato. Adatta a come sono i tuoi appuntamenti reali.
    return Appointment(
      id: map['id']?.toString() ?? 'unknown',
      date: map['data'] ?? 'unknown',
      time: map['ora'] ?? 'unknown',
      description: map['descrizione'] ?? 'Appuntamento',
    );
  }
}

// Risposta dopo aver prenotato un appuntamento
class BookAppointmentResponse {
  final bool success;
  final int id;

  BookAppointmentResponse({required this.success, required this.id});

  factory BookAppointmentResponse.fromMap(Map<String, dynamic> map) {
    return BookAppointmentResponse(
      success: map['success'] as bool,
      id: map['id'] as int,
    );
  }
}

// Risposta dopo aver ordinato un farmaco
class OrderDrugResponse {
  final bool success;
  final int id; // ID dell'ordine del farmaco

  OrderDrugResponse({required this.success, required this.id});

  factory OrderDrugResponse.fromMap(Map<String, dynamic> map) {
    return OrderDrugResponse(
      success: map['success'] as bool,
      id: map['id'] as int,
    );
  }
}
